import logging
import asyncio
import sqlite3
import os
from collections import deque
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from google import genai

logging.basicConfig(level=logging.INFO)

TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN") 
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")

if not TELEGRAM_TOKEN or not GOOGLE_API_KEY:
    print("‚ùå –û–®–ò–ë–ö–ê: –ö–ª—é—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!")
    exit(1)

client = genai.Client(api_key=GOOGLE_API_KEY)
dp = Dispatcher()
chat_history = {}

conn = sqlite3.connect('debts.db')
cursor = conn.cursor()
cursor.execute('''CREATE TABLE IF NOT EXISTS debts (who TEXT, to_whom TEXT, amount REAL, reason TEXT)''')
conn.commit()

@dp.message(Command("–±–æ—Ç"))
async def ask_bot(message: types.Message):
    q = message.text.replace("/–±–æ—Ç", "").strip()
    if not q: return await message.reply("‚ùì")
    wait = await message.reply("üß†")
    try:
         res = client.models.generate_content(model="gemini-1.5-flash", contents=q)
         await wait.edit_text(res.text if res.text else "–ü—É—Å—Ç–æ.")
    except Exception as e: await wait.edit_text(f"–û—à–∏–±–∫–∞: {e}")

@dp.message(Command("–¥–æ–ª–≥"))
async def add_debt(message: types.Message):
    try:
        args = message.text.split()
        if len(args) < 4: return await message.reply("–§–æ—Ä–º–∞—Ç: /–¥–æ–ª–≥ @–∫–æ–º—É —Å—É–º–º–∞ –∑–∞_—á—Ç–æ")
        to, amt, rsn = args[1], float(args[2].replace(',', '.')), " ".join(args[3:])
        who = f"@{message.from_user.username}" if message.from_user.username else message.from_user.first_name
        cursor.execute("INSERT INTO debts VALUES (?, ?, ?, ?)", (who, to, amt, rsn))
        conn.commit()
        await message.reply(f"‚úÖ {to} –¥–æ–ª–∂–µ–Ω {who} {amt}—Ä.")
    except: await message.reply("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.")

@dp.message(Command("–±–∞–ª–∞–Ω—Å"))
async def show(message: types.Message):
    cursor.execute("SELECT * FROM debts")
    rows = cursor.fetchall()
    if not rows: return await message.reply("–ß–∏—Å—Ç–æ.")
    text = "\n".join([f"üî¥ {r[1]} -> {r[0]}: {r[2]} ({r[3]})" for r in rows])
    await message.reply(f"üìí **–î–æ–ª–≥–∏:**\n{text}\n\n–°–±—Ä–æ—Å: /–ø—Ä–æ—Å—Ç–∏—Ç—å_–≤—Å–µ", parse_mode="Markdown")

@dp.message(Command("–ø—Ä–æ—Å—Ç–∏—Ç—å_–≤—Å–µ"))
async def clear(message: types.Message):
    cursor.execute("DELETE FROM debts"); conn.commit()
    await message.reply("üéâ")

@dp.message(Command("—Å—É–¥–∏"))
async def judge(message: types.Message):
    cid = message.chat.id
    if cid not in chat_history: return await message.reply("–¢–∏—à–∏–Ω–∞...")
    msg = await message.reply("‚öñÔ∏è")
    try:
        resp = client.models.generate_content(model="gemini-1.5-flash", contents=f"–†–∞—Å—Å—É–¥–∏ —Å–º–µ—à–Ω–æ:\n{chr(10).join(chat_history[cid])}")
        await msg.edit_text(resp.text)
    except Exception as e: await msg.edit_text(str(e))

@dp.message()
async def hist(message: types.Message):
    if message.text and not message.text.startswith('/'):
        cid = message.chat.id
        if cid not in chat_history: chat_history[cid] = deque(maxlen=40)
        chat_history[cid].append(f"{message.from_user.first_name}: {message.text}")

async def main():
    print("üöÄ –°—Ç–∞—Ä—Ç –Ω–∞ Render...")
    bot = Bot(token=TELEGRAM_TOKEN)
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())